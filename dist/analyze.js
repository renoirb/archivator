'use strict';let extractWords=(()=>{var _ref=_asyncToGenerator(function*(recv,source){const loaded=(0,_common.cheerioLoad)(recv);return loaded.then(function(shard){const{_,truncate}=(0,_common.figureOutTruncateAndSelector)(source);shard(truncate).remove();const text=shard.text().split(' ');const words=Object.create(null);const foundOnce=new Set;for(let i=0;i<text.length;i++){const word=transformText(text[i]);const withinCharRange=/^[a-zA-ZÀ-ÖØ-öø-ÿ]+$/.test(word);const isNotStopWord=stopWords.has(word)===false;const hasAtLeastTwo=word.length>1;if(withinCharRange&&isNotStopWord&&hasAtLeastTwo){if(foundOnce.has(word)===false){foundOnce.add(word)}else if(Object.prototype.hasOwnProperty.call(words,word)){words[word]++}else{words[word]=2}}}return words})});return function extractWords(_x,_x2){return _ref.apply(this,arguments)}})();let read=(()=>{var _ref2=_asyncToGenerator(function*(source){const path=`archive/${source.slug}`;const cacheFile=`${path}/cache.html`;const targetFileName=`${path}/analyze.json`;const cacheExists=yield fsa.exists(cacheFile);const data=Object.create(null);if(cacheExists===true){const cacheData=yield(0,_common.readCached)(cacheFile);const words=yield extractWords(cacheData,source);data.words=words}console.log(`\nProcessing ${path}`);return{file:targetFileName,data}});return function read(_x3){return _ref2.apply(this,arguments)}})();let analyze=(()=>{var _ref3=_asyncToGenerator(function*(recv){const words=recv.data.words||{};const keywords=Object.create(null);const sorted=sort(words);const max=10;let iter=0;for(const popular of sorted){const used=popular[1];// word has been used n times
const word=popular[0];if(iter<=max&&used>3){keywords[word]=used}iter++}const wordCount=Object.keys(words).length;const paddedCounter=String(wordCount).padStart('5',' ');let logLine=paddedCounter+' words found';console.log(logLine);const firstThreeKeywords=Object.keys(keywords).slice(0,3).join(', ');logLine='      Top keywords: '+firstThreeKeywords;console.log(logLine);recv.data.keywords=keywords;return recv});return function analyze(_x4){return _ref3.apply(this,arguments)}})();let write=(()=>{var _ref4=_asyncToGenerator(function*({file,data={}},boolOverwrite=false){const destExists=yield fsa.exists(file);if(destExists===false||destExists===true&&boolOverwrite){yield fsa.writeTextFile(file,JSON.stringify(data),'utf8')}return{file,data}});return function write(_x5){return _ref4.apply(this,arguments)}})();/**
 * Something is going somewhat as an anti-pattern here.
 * We want Promise.all(...) at each step, and it's not how
 * it is as of now. Needs rework here. TODO
 */var _asyncFile=require('async-file');var fsa=_interopRequireWildcard(_asyncFile);var _common=require('./common');function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key]=obj[key]}}newObj.default=obj;return newObj}}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}/**
 * https://www.ranks.nl/stopwords
 * http://xpo6.com/list-of-english-stop-words/
 */const stopWords=new Set(require('./stopwords'));const URL_LIST='archive/index.csv';const OVERWRITE=true;function transformText(input){const dto=String(input)||'';return dto.replace(/[^\w\s]|_/g,'').toLowerCase()}function sort(subject={}){const sortable=[];for(const key in subject){if(typeof key==='string'){sortable.push([key,subject[key]])}}// Sort from more occurences, to least
sortable.sort((a,b)=>{return-1*(a[1]-b[1])});return sortable;// array in format [ [ key1, val1 ], [ key2, val2 ], ... ]
}for(const url of(0,_common.readLines)(URL_LIST)){Promise.resolve(url).then(u=>read(u)).then(descriptor=>analyze(descriptor)).then(descriptor=>write(descriptor,OVERWRITE)).catch(_common.handleIndexSourceErrors)}
//# sourceMappingURL=analyze.js.map