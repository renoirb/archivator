{"version":3,"sources":["../src/analyze.js"],"names":["recv","source","loaded","then","_","truncate","shard","remove","text","split","words","Object","create","foundOnce","Set","i","length","word","transformText","withinCharRange","test","isNotStopWord","stopWords","has","hasAtLeastTwo","add","prototype","hasOwnProperty","call","extractWords","path","slug","cacheFile","targetFileName","cacheExists","fsa","exists","data","cacheData","console","log","file","read","keywords","sorted","sort","max","iter","popular","used","wordCount","keys","paddedCounter","String","padStart","logLine","firstThreeKeywords","slice","join","analyze","boolOverwrite","destExists","writeTextFile","JSON","stringify","write","require","URL_LIST","OVERWRITE","input","dto","replace","toLowerCase","subject","sortable","key","push","a","b","url","Promise","resolve","u","descriptor","catch"],"mappings":"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","file":"analyze.js","sourcesContent":["'use strict';\n\nimport * as fsa from 'async-file';\n\nimport {\n  readLines,\n  handleIndexSourceErrors,\n  readCached,\n  figureOutTruncateAndSelector,\n  cheerioLoad\n} from './common';\n\n/**\n * https://www.ranks.nl/stopwords\n * http://xpo6.com/list-of-english-stop-words/\n */\nconst stopWords = new Set(require('./stopwords'));\n\nconst URL_LIST = 'archive/index.csv';\nconst OVERWRITE = true;\n\nfunction transformText(input) {\n  const dto = String(input) || '';\n  return dto.replace(/[^\\w\\s]|_/g, '').toLowerCase();\n}\n\nasync function extractWords(recv, source) {\n  const loaded = cheerioLoad(recv);\n  return loaded.then(shard => {\n    const {_, truncate} = figureOutTruncateAndSelector(source);\n    shard(truncate).remove();\n    const text = shard.text().split(' ');\n    const words = Object.create(null);\n    const foundOnce = new Set();\n    for (let i = 0; i < text.length; i++) {\n      const word = transformText(text[i]);\n      const withinCharRange = /^[a-zA-ZÀ-ÖØ-öø-ÿ]+$/.test(word);\n      const isNotStopWord = stopWords.has(word) === false;\n      const hasAtLeastTwo = word.length > 1;\n      if (withinCharRange && isNotStopWord && hasAtLeastTwo) {\n        if (foundOnce.has(word) === false) {\n          foundOnce.add(word);\n        } else if (Object.prototype.hasOwnProperty.call(words, word)) {\n          words[word]++;\n        } else {\n          words[word] = 2;\n        }\n      }\n    }\n    return words;\n  });\n}\n\nasync function read(source) {\n  const path = `archive/${source.slug}`;\n  const cacheFile = `${path}/cache.html`;\n  const targetFileName = `${path}/analyze.json`;\n  const cacheExists = await fsa.exists(cacheFile);\n  const data = Object.create(null);\n  if (cacheExists === true) {\n    const cacheData = await readCached(cacheFile);\n    const words = await extractWords(cacheData, source);\n    data.words = words;\n  }\n\n  console.log(`\\nProcessing ${path}`);\n  return {file: targetFileName, data};\n}\n\nfunction sort(subject = {}) {\n  const sortable = [];\n  for (const key in subject) {\n    if (typeof key === 'string') {\n      sortable.push([key, subject[key]]);\n    }\n  }\n  // Sort from more occurences, to least\n  sortable.sort((a, b) => {\n    return -1 * (a[1] - b[1]);\n  });\n\n  return sortable; // array in format [ [ key1, val1 ], [ key2, val2 ], ... ]\n}\n\nasync function analyze(recv) {\n  const words = recv.data.words || {};\n  const keywords = Object.create(null);\n  const sorted = sort(words);\n  const max = 10;\n  let iter = 0;\n  for (const popular of sorted) {\n    const used = popular[1]; // word has been used n times\n    const word = popular[0];\n    if (iter <= max && used > 3) {\n      keywords[word] = used;\n    }\n    iter++;\n  }\n\n  const wordCount = Object.keys(words).length;\n  const paddedCounter = String(wordCount).padStart('5', ' ');\n  let logLine = paddedCounter + ' words found';\n  console.log(logLine);\n  const firstThreeKeywords = Object.keys(keywords).slice(0, 3).join(', ');\n  logLine = '      Top keywords: ' + firstThreeKeywords;\n  console.log(logLine);\n\n  recv.data.keywords = keywords;\n\n  return recv;\n}\n\nasync function write({file, data = {}}, boolOverwrite = false) {\n  const destExists = await fsa.exists(file);\n  if (destExists === false || (destExists === true && boolOverwrite)) {\n    await fsa.writeTextFile(file, JSON.stringify(data), 'utf8');\n  }\n\n  return {file, data};\n}\n\n/**\n * Something is going somewhat as an anti-pattern here.\n * We want Promise.all(...) at each step, and it's not how\n * it is as of now. Needs rework here. TODO\n */\nfor (const url of readLines(URL_LIST)) {\n  Promise.resolve(url)\n    .then(u => read(u))\n    .then(descriptor => analyze(descriptor))\n    .then(descriptor => write(descriptor, OVERWRITE))\n    .catch(handleIndexSourceErrors);\n}\n"]}