{"version":3,"sources":["../src/markdownify.js"],"names":["descriptor","html","cache","assets","source","cheerioConfig","then","references","Object","create","forEach","ref","match","name","shard","each","_","element","attr","src","newSrc","selector","truncate","title","text","remove","body","frontMatter","meta","dto","simplified","key","prototype","hasOwnProperty","call","push","top","join","bottom","markdownify","fileName","file","exists","overwrite","contents","analyze","keywords","keys","url","markdownified","handle","fsa","writeTextFile","overwriteOption","path","slug","data","cacheFile","cacheExists","assetsFile","assetsExists","assetsFileContents","JSON","parse","analyzeFile","analyzeExists","analyzeFileContents","targetFileName","markdownifiedExists","console","log","read","normalizeWhitespace","xmlMode","decodeEntities","URL_LIST","OVERWRITE","Promise","resolve","u","handled","catch"],"mappings":"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","file":"markdownify.js","sourcesContent":["'use strict';\n\nimport * as fsa from 'async-file';\nimport htmlmd from 'html-md-2';\n\nimport {\n  readLines,\n  handleIndexSourceErrors,\n  readCached,\n  figureOutTruncateAndSelector,\n  cheerioLoad\n} from './common';\n\nconst cheerioConfig = {normalizeWhitespace: true, xmlMode: false, decodeEntities: true};\n\nconst URL_LIST = 'archive/index.csv';\nconst OVERWRITE = true;\n\nasync function markdownify(descriptor) {\n  const html = descriptor.cache;\n  const assets = descriptor.assets.assets;\n  const source = descriptor.source;\n  return cheerioLoad(html, cheerioConfig)\n          .then(shard => {\n              /**\n               * Each references dictionary should look like this;\n               * ```\n               * { 'http://example.org/a.png': '6c65613db26a19d838c0359989f941c303c04474.png',\n               *   'http://example.org/a.webm': '5c737acd98c723bbed666bbfb3d14a8e0d34266b.webm' }\n               * ```\n               */\n            const references = Object.create(null);\n            assets.forEach(ref => {\n              references[ref.match] = ref.name;\n            });\n            return {references, shard};\n          })\n          .then(({references, shard}) => {\n            shard('img[src]').each((_, element) => {\n                  /**\n                   * What we receive looks like this;\n                   * ```\n                   * { '_': 0,\n                   *   'element':\n                   *    { type: 'tag',\n                   *      name: 'img',\n                   *      attribs:\n                   *       { src: 'http://example.org/a.png',\n                   *         alt: 'A Image Alt text',\n                   *         class: 'example img class-name list' },\n                   *      children: [],\n                   *      next: null,\n                   *      prev: {},\n                   *      parent: {} } }\n                   * ```\n                   */\n              shard(element).attr('class', null);\n              const src = shard(element).attr('src');\n                  /**\n                   * Assuming our references object (see above) has a key\n                   * (e.g. http://example.org/a.png) with a matching\n                   * value (e.g. 6c65613db26a19d838c0359989f941c303c04474.png)\n                   * we replace the img[src] value with it.\n                   * That way, our Markdownified file will refer to archived\n                   * assets beside it instead of ones from source origin.\n                   */\n              const newSrc = (typeof references[src] === 'string') ? references[src] : src + '?err=CouldNotFind';\n              shard(element).attr('src', newSrc);\n            });\n\n            return shard;\n          })\n          .then(shard => {\n            const {selector, truncate} = figureOutTruncateAndSelector(source);\n            const title = shard('title').text();\n            shard(truncate).remove();\n            const body = shard(selector).html();\n            const frontMatter = {title};\n\n            return {meta: frontMatter, body};\n          })\n          .then(simplified => {\n            const dto = [];\n            const meta = simplified.meta;\n            for (const key in meta) {\n              if (Object.prototype.hasOwnProperty.call(meta, key)) {\n                dto.push(`${key}: \"${meta[key]}\"`);\n              }\n            }\n            const top = dto.join(`\\n`);\n            const bottom = htmlmd(simplified.body);\n\n            return `${top}\\n\\n---\\n\\n${bottom}\\n`;\n          });\n}\n\nasync function handle(descriptor) {\n  const fileName = descriptor.file.name;\n  if (\n    (descriptor.file.exists === false) ||\n    (descriptor.file.exists === true && descriptor.file.overwrite === true)\n  ) {\n    const source = descriptor.source;\n    let contents = '';\n    if (Object.prototype.hasOwnProperty.call(descriptor.analyze || {}, 'keywords')) {\n      const keywords = Object.keys(descriptor.analyze.keywords);\n      contents += `keywords: [${keywords}]\\n`;\n    }\n    contents += `url: \"${source.url}\"\\n`;\n    const markdownified = await markdownify(descriptor);\n    contents += markdownified;\n    return {\n      fileName,\n      contents\n    };\n  }\n}\n\nasync function writeTextFile({\n    fileName,\n    contents\n}) {\n  await fsa.writeTextFile(fileName, contents, 'utf8');\n}\n\nasync function read(source, overwriteOption) {\n  const path = `archive/${source.slug}`;\n  const data = Object.create(null);\n  data.source = source;\n  const cacheFile = `${path}/cache.html`;\n  const cacheExists = await fsa.exists(cacheFile);\n  if (cacheExists) {\n    data.cache = await readCached(cacheFile);\n  }\n  const assetsFile = `${path}/assets.json`;\n  const assetsExists = await fsa.exists(assetsFile);\n  if (assetsExists) {\n    const assetsFileContents = await readCached(assetsFile);\n    data.assets = JSON.parse(assetsFileContents);\n  }\n  const analyzeFile = `${path}/analyze.json`;\n  const analyzeExists = await fsa.exists(analyzeFile);\n  if (analyzeExists) {\n    const analyzeFileContents = await readCached(analyzeFile);\n    data.analyze = JSON.parse(analyzeFileContents);\n  }\n  const targetFileName = `${path}/index.md`;\n  const markdownifiedExists = await fsa.exists(targetFileName);\n  data.file = {exists: markdownifiedExists, name: targetFileName, overwrite: overwriteOption};\n\n  console.log(`Markdownifying ${data.file.name}`);\n\n  return data;\n}\n\n/**\n * Something is going somewhat as an anti-pattern here.\n * We want Promise.all(...) at each step, and it's not how\n * it is as of now. Needs rework here. TODO\n */\nfor (const url of readLines(URL_LIST)) {\n  Promise.resolve(url)\n    .then(u => read(u, OVERWRITE))\n    .then(descriptor => handle(descriptor))\n    .then(descriptor => handle(descriptor))\n    .then(handled => writeTextFile(handled))\n    .catch(handleIndexSourceErrors);\n}\n"]}