{"version":3,"sources":["../../src/normalizer/assets.js"],"names":["sourceDocument","asset","sourceDocumentUrlObj","err","Error","targetGiven","String","href","replace","targetAsset","hasFileExtensionRegEx","startWithHttpsRegEx","startWithHttpMaybeTlsRegEx","startWithDoublySlashRegEx","startWithOneSlashRegEx","endWithOneSlashRegEx","test","pathname","origin","targetAssetPathnameArray","split","filter","n","pop","join","protocol","hostname","goUp","match","tempTargetGivenUrlObj","targetGivenPathname","isTargetAssetGoUpOverflow","length","sliceUntilHowMany","newTargetGivenPathname","slice","targetAssetArray","concat","ret"],"mappings":"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","file":"assets.js","sourcesContent":["import {URL} from 'url';\n\n/**\n * Asset URL normalizer\n *\n * Given we have an article URL at http://example.org/foo/bar/baz.html\n * (refered to as \"sourceDocument\") where we can have many image tags we want\n * to keep a copy (e.g. <img src=\"/image/a.jpg\" />, refered here as \"asset\").\n * We want to know where should we download /image/a.jpg from.\n * To do this, we can figure out by combining the sourceDocument and the asset\n *\n * For a given sourceDocument URL with 0 or more assets in document's HTML,\n * we want to get output as:\n * [ http://example.org/image/a.jpg,\n *   ... ]\n *\n * This module should handle all valid asset paths and return\n * a fully qualified URL so we can download the asset.\n *\n * For example, the URL of a sourceDocument could be \"http://example.org/foo/bar.html\"\n * with images (\"asset\" img tags with src=\"...\") img[src] values;\n *\n * - /a/b.jpg                      => http://example.org/a/b.jpg\n * - a/b.jpg                       => http://example.org/foo/a/b.jpg\n * - a/b                           => http://example.org/foo/a/b\n * - ../a/b.jpg                    => http://example.org/a/b.jpg\n * - a/b.jpg?foo=bar               => http://example.org/foo/a/b.jpg?foo=bar\n * - //example.org/a/b.jpg         => http://example.org/a/b.jpg\n * - http://elsewhere.org/a/b.jpg  => http://elsewhere.org/a/b.jpg\n * - https://example.org/a/b.jpg   => https://example.org/a/b.jpg\n */\nexport default (sourceDocument, asset) => {\n  // console.log(`Given: ${sourceDocument}, Asset: ${asset}`); // DEBUG\n  let sourceDocumentUrlObj = {};\n\n  try {\n    /**\n     * Here are a few representation of an URL instance with\n     * varying possible values.\n     *\n     * URL {\n     *   href: 'http://example.org/a.html',\n     *   origin: 'http://example.org',\n     *   protocol: 'http:',\n     *   username: '',\n     *   password: '',\n     *   host: 'example.org',\n     *   hostname: 'example.org',\n     *   port: '',\n     *   pathname: '/a.html',\n     *   search: '',\n     *   searchParams: URLSearchParams {},\n     *   hash: '' }\n     *\n     * Without an ending slash\n     *\n     * URL {\n     *    href: 'http://example.org/a',\n     *    ...\n     *    pathname: '/a',\n     *    ... }\n     *\n     * With an ending slash\n     *\n     *    URL {\n     *      href: 'http://example.org/a/',\n     *      ...\n     *      pathname: '/a/',\n     *      ... }\n     *\n     */\n    sourceDocumentUrlObj = new URL(sourceDocument);\n    // console.log(sourceDocumentUrlObj); // DEBUG\n  } catch (err) {\n    throw new Error(sourceDocument, err);\n  }\n\n  let targetGiven = String(sourceDocumentUrlObj.href)\n        .replace(/([a-z0-9_\\-.:])$/i, '$1/');\n\n  let targetAsset = String(asset)\n        .replace(/^\\.\\//, '');\n\n  const hasFileExtensionRegEx = /\\.(html?|do|action)/;\n\n  const startWithHttpsRegEx = /^https:\\/\\//;\n\n  const startWithHttpMaybeTlsRegEx = /^https?:\\/\\//;\n\n  const startWithDoublySlashRegEx = /^\\/\\//;\n\n  const startWithOneSlashRegEx = /^\\/(?!\\/)/;\n\n  const endWithOneSlashRegEx = /\\/(?!\\/)$/;\n\n  /**\n   * File with an extension (e.g. /index.html, /action.do)\n   * should not be treated as folders.\n   */\n  if (hasFileExtensionRegEx.test(sourceDocumentUrlObj.pathname) === true) {\n    targetGiven = String(`${sourceDocumentUrlObj.origin}/`);\n    if (startWithOneSlashRegEx.test(asset) === false) {\n      // If asset DOES NOT start with a slash (e.g. <img src=\"a.png\" />)\n      // An array out of the URL, without empty members\n      // e.g. '/a/c.html' => [ '', 'a', 'c.html' ]\n      const targetAssetPathnameArray = sourceDocumentUrlObj.pathname.split('/').filter(n => n);\n      targetAssetPathnameArray.pop(); // Strip off file and extension member\n      targetGiven += targetAssetPathnameArray.join('/');\n      if (endWithOneSlashRegEx.test(targetGiven) === false) {\n        targetGiven += '/';\n      }\n    }\n    // Make sure targetGiven ENDS with slash. http://example.org/a/\n  }\n\n  /**\n   * If targetAsset starts by /, we explicitly want\n   * to start directly from the top of the\n   * folder hirerarchy\n   * e.g. /a.png\n   */\n  if (startWithOneSlashRegEx.test(targetAsset)) {\n    // console.log(`Start from top top most parent directory \"${targetAsset}\"`); // DEBUG\n    targetGiven = String(`${sourceDocumentUrlObj.protocol}//${sourceDocumentUrlObj.hostname}/`);\n    targetAsset = targetAsset.replace(startWithOneSlashRegEx, '');\n    // Make sure if we had a / at the asset, it's stripped off uniformally\n    // {asset: '/a.png', targetGiven: 'http://example.org/', targetAsset: 'a.png'}\n  }\n\n  /**\n   * How many times has the asset contains \"../\"\n   * and let's handle how deep we can go to a parent directory.\n   *\n   * Here are a few possible edge cases.\n   *\n   * ```\n   * ----\n   * Equal number directory deep and request for going up.\n   * [ { sourceDocument: 'http://example.org/ignored/also_ignored/and_too',\n   *     targetGiven: 'http://example.org/ignored/also_ignored/and_too/' },\n   *   { asset: '../../../a.jpg', targetAsset: '../../../a.jpg' },\n   *   { isTargetAssetGoUpOverflow: false,\n   *     targetGivenPathname: 3,\n   *     goUp: 3,\n   *     targetAssetArray: [ 'a.jpg' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   *\n   * ----\n   * [ { sourceDocument: 'http://example.org/ignored/also_ignored/',\n   *     targetGiven: 'http://example.org/ignored/also_ignored/' },\n   *   { asset: '../../a.jpg', targetAsset: '../../a.jpg' },\n   *   { isTargetAssetGoUpOverflow: false,\n   *     targetGivenPathname: 2,\n   *     goUp: 2,\n   *     targetAssetArray: [ 'a.jpg' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   *\n   * ----\n   * File has extension, we cannot treat it as a directory.\n   * [ { sourceDocument: 'http://example.org/b/c.html',\n   *     targetGiven: 'http://example.org/b/' },\n   *   { asset: '../a.png', targetAsset: '../a.png' },\n   *   { isTargetAssetGoUpOverflow: false,\n   *     targetGivenPathname: 1,\n   *     goUp: 1,\n   *     targetAssetArray: [ 'a.png' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   *\n   * ----\n   * Here, we are asking to go beyond one directory deep.\n   * Notice isTargetAssetGoUpOverflow is true.\n   * [ { sourceDocument: 'http://example.org/b/c.html',\n   *     targetGiven: 'http://example.org/' },\n   *   { asset: '../../../../../a.png', targetAsset: 'a.png' },\n   *   { isTargetAssetGoUpOverflow: true,\n   *     targetGivenPathname: 1,\n   *     goUp: 5,\n   *     targetAssetArray: [ 'a.png' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   * ```\n   */\n  if (/\\.\\.\\//.test(targetAsset)) {\n    const goUp = targetAsset.match(/\\.\\.\\//g);\n    // console.log(`Has go up parent operator in path \"${targetAsset}\", found ${goUp.length} times`); // DEBUG\n    const tempTargetGivenUrlObj = new URL(targetGiven);\n    const targetGivenPathname = tempTargetGivenUrlObj.pathname.split('/').filter(n => n);\n    const isTargetAssetGoUpOverflow = targetGivenPathname.length < goUp.length;\n    let sliceUntilHowMany = targetGivenPathname.length - goUp.length;\n\n    // Make sure this edge-case is taken into account so that we can still\n    // calculate how deep we go without overriding.\n    // Maybe that's a mutually exclusive scenario and we need to else from here.\n    if (isTargetAssetGoUpOverflow === true) {\n      // Assuming we have impossible to reach, we got to stop at the origin:\n      // targetGiven = http://example.org/\n      // targetAsset = ../../bogus.png\n      // Force so we serve at the top http://example.org/bogus.png\n      sliceUntilHowMany = 0;\n    }\n\n    const newTargetGivenPathname = targetGivenPathname.slice(0, sliceUntilHowMany);\n    const targetAssetArray = newTargetGivenPathname.concat(targetAsset.split('/').filter(n => n !== '..'));\n    // console.log([{sourceDocument, targetGiven}, {asset, targetAsset}, {isTargetAssetGoUpOverflow, targetGivenPathname: targetGivenPathname.length, goUp: goUp.length, targetAssetArray, newTargetGivenPathname, sliceUntilHowMany}]);\n    targetGiven = String(`${sourceDocumentUrlObj.origin}/`);\n    targetAsset = String(`${targetAssetArray.join('/')}`);\n  }\n\n  /**\n   * If targetAsset starts by https?://, we ignore targetGiven\n   */\n  if (startWithHttpMaybeTlsRegEx.test(asset) === true) {\n    targetGiven = '';\n  }\n\n  /**\n   * If targetAsset starts by //, we ignore targetGiven\n   */\n  if (startWithDoublySlashRegEx.test(asset) === true) {\n    targetGiven = (startWithHttpsRegEx.test(sourceDocumentUrlObj.href) === true) ? 'https:' : 'http:';\n  }\n\n  const ret = String(`${targetGiven}${targetAsset}`);\n  // console.log('normalizer/assets', ret); // DEBUG\n\n  return ret;\n};\n"]}