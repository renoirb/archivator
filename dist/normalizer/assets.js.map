{"version":3,"sources":["../../src/normalizer/assets.js"],"names":["given","asset","urlObj","err","Error","targetGiven","String","href","replace","targetAsset","hasFileExtensionRegEx","startWithHttpsRegEx","startWithHttpMaybeTlsRegEx","startWithDoublySlashRegEx","startWithOneSlashRegEx","endWithOneSlashRegEx","test","pathname","origin","targetAssetPathnameArray","split","filter","n","pop","join","protocol","hostname","goUp","match","tempTargetGivenUrlObj","targetGivenPathname","isTargetAssetGoUpOverflow","length","sliceUntilHowMany","newTargetGivenPathname","slice","targetAssetArray","concat","ret"],"mappings":"AAAA,a,yDAEA,wBAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA+De,CAACA,KAAD,CAAQC,KAAR,GAAkB,CAC/B;AACA,GAAIC,QAAS,EAAb,CAEA,GAAI,CACFA,OAAS,aAAQF,KAAR,CAAT,CACA;AACD,CAAC,MAAOG,GAAP,CAAY,CACZ,KAAM,IAAIC,MAAJ,CAAUJ,KAAV,CAAiBG,GAAjB,CACP,CAED,GAAIE,aAAcC,OAAOJ,OAAOK,IAAd,EACXC,OADW,CACH,mBADG,CACkB,KADlB,CAAlB,CAGA,GAAIC,aAAcH,OAAOL,KAAP,EACXO,OADW,CACH,OADG,CACM,EADN,CAAlB,CAGA,KAAME,uBAAwB,qBAA9B,CAEA,KAAMC,qBAAsB,aAA5B,CAEA,KAAMC,4BAA6B,cAAnC,CAEA,KAAMC,2BAA4B,OAAlC,CAEA,KAAMC,wBAAyB,WAA/B,CAEA,KAAMC,sBAAuB,WAA7B,CAEA;;;KAIA,GAAIL,sBAAsBM,IAAtB,CAA2Bd,OAAOe,QAAlC,IAAgD,IAApD,CAA0D,CACxDZ,YAAcC,OAAQ,GAAEJ,OAAOgB,MAAO,GAAxB,CAAd,CACA,GAAIJ,uBAAuBE,IAAvB,CAA4Bf,KAA5B,IAAuC,KAA3C,CAAkD,CAChD;AACA;AACA;AACA;AACA,KAAMkB,0BAA2BjB,OAAOe,QAAP,CAAgBG,KAAhB,CAAsB,GAAtB,EAA2BC,MAA3B,CAAkCC,GAAKA,CAAvC,CAAjC,CACAH,yBAAyBI,GAAzB,GAAgC;AAChClB,aAAec,yBAAyBK,IAAzB,CAA8B,GAA9B,CAAf,CACA,GAAIT,qBAAqBC,IAArB,CAA0BX,WAA1B,IAA2C,KAA/C,CAAsD,CACpDA,aAAe,GAChB,CACF,CACD;AACD,CAED;;;;;KAMA,GAAIS,uBAAuBE,IAAvB,CAA4BP,WAA5B,CAAJ,CAA8C,CAC5C;AACAJ,YAAcC,OAAQ,GAAEJ,OAAOuB,QAAS,KAAIvB,OAAOwB,QAAS,GAA9C,CAAd,CACAjB,YAAcA,YAAYD,OAAZ,CAAoBM,sBAApB,CAA4C,EAA5C,CAAd,CACA;AACA;AACD,CAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAwDA,GAAI,SAASE,IAAT,CAAcP,WAAd,CAAJ,CAAgC,CAC9B,KAAMkB,MAAOlB,YAAYmB,KAAZ,CAAkB,SAAlB,CAAb,CACA;AACA,KAAMC,uBAAwB,aAAQxB,WAAR,CAA9B,CACA,KAAMyB,qBAAsBD,sBAAsBZ,QAAtB,CAA+BG,KAA/B,CAAqC,GAArC,EAA0CC,MAA1C,CAAiDC,GAAKA,CAAtD,CAA5B,CACA,KAAMS,2BAA4BD,oBAAoBE,MAApB,CAA6BL,KAAKK,MAApE,CACA,GAAIC,mBAAoBH,oBAAoBE,MAApB,CAA6BL,KAAKK,MAA1D,CAEA;AACA;AACA;AACA,GAAID,4BAA8B,IAAlC,CAAwC,CACtC;AACA;AACA;AACA;AACAE,kBAAoB,CACrB,CAED,KAAMC,wBAAyBJ,oBAAoBK,KAApB,CAA0B,CAA1B,CAA6BF,iBAA7B,CAA/B,CACA,KAAMG,kBAAmBF,uBAAuBG,MAAvB,CAA8B5B,YAAYW,KAAZ,CAAkB,GAAlB,EAAuBC,MAAvB,CAA8BC,GAAKA,IAAM,IAAzC,CAA9B,CAAzB,CACA;AACAjB,YAAcC,OAAQ,GAAEJ,OAAOgB,MAAO,GAAxB,CAAd,CACAT,YAAcH,OAAQ,GAAE8B,iBAAiBZ,IAAjB,CAAsB,GAAtB,CAA2B,EAArC,CACf,CAED;;KAGA,GAAIZ,2BAA2BI,IAA3B,CAAgCf,KAAhC,IAA2C,IAA/C,CAAqD,CACnDI,YAAc,EACf,CAED;;KAGA,GAAIQ,0BAA0BG,IAA1B,CAA+Bf,KAA/B,IAA0C,IAA9C,CAAoD,CAClDI,YAAeM,oBAAoBK,IAApB,CAAyBd,OAAOK,IAAhC,IAA0C,IAA3C,CAAmD,QAAnD,CAA8D,OAC7E,CAED,KAAM+B,KAAMhC,OAAQ,GAAED,WAAY,GAAEI,WAAY,EAApC,CAAZ,CACA;AAEA,MAAO6B,IACR,C","file":"assets.js","sourcesContent":["'use strict';\n\nimport {URL} from 'url';\n\n/**\n * Asset URL normalizer\n *\n * Given we have an article on http://example.org/foo/bar/baz.html\n * (refered to as \"given\") where an image tag contains /image/a.jpg\n * (refered to as \"asset\").\n * Typically an asset would be in an <img /> tag that would look like\n * this <img src=\"/a/b.jpg\" />.\n * In this example, the image path would be http://example.org/a/b.jpg.\n * because the src attribute started by a slash.\n *\n * What would be the other valid values an img[src] contain?\n *\n * - /a/b.jpg\n * - a/b.jpg\n * - a/b\n * - ../a/b.jpg\n * - a/b.jpg?foo=bar\n * - //example.org/a/b.jpg\n * - http://elsewhere.org/a/b.jpg\n * - http://example.org/a/b.jpg\n * - https://example.org/a/b.jpg\n *\n * Each reference are relative to the path of document in\n * relation to the origin (e.g. http://example.org) and\n * the protocol (e.g. https:).\n *\n * ------------------------------------------------------\n *\n * Here are a few representation of an URL instance with\n * varying possible values.\n *\n * URL {\n *   href: 'http://example.org/a.html',\n *   origin: 'http://example.org',\n *   protocol: 'http:',\n *   username: '',\n *   password: '',\n *   host: 'example.org',\n *   hostname: 'example.org',\n *   port: '',\n *   pathname: '/a.html',\n *   search: '',\n *   searchParams: URLSearchParams {},\n *   hash: '' }\n *\n * Without an ending slash\n *\n * URL {\n *    href: 'http://example.org/a',\n *    ...\n *    pathname: '/a',\n *    ... }\n *\n * With an ending slash\n *\n *    URL {\n *      href: 'http://example.org/a/',\n *      ...\n *      pathname: '/a/',\n *      ... }\n *\n */\nexport default (given, asset) => {\n  // console.log(`Given: ${given}, Asset: ${asset}`); // DEBUG\n  let urlObj = {};\n\n  try {\n    urlObj = new URL(given);\n    // console.log(urlObj); // DEBUG\n  } catch (err) {\n    throw new Error(given, err);\n  }\n\n  let targetGiven = String(urlObj.href)\n        .replace(/([a-z0-9_\\-.:])$/i, '$1/');\n\n  let targetAsset = String(asset)\n        .replace(/^\\.\\//, '');\n\n  const hasFileExtensionRegEx = /\\.(html?|do|action)/;\n\n  const startWithHttpsRegEx = /^https:\\/\\//;\n\n  const startWithHttpMaybeTlsRegEx = /^https?:\\/\\//;\n\n  const startWithDoublySlashRegEx = /^\\/\\//;\n\n  const startWithOneSlashRegEx = /^\\/(?!\\/)/;\n\n  const endWithOneSlashRegEx = /\\/(?!\\/)$/;\n\n  /**\n   * File with an extension (e.g. /index.html, /action.do)\n   * should not be treated as folders.\n   */\n  if (hasFileExtensionRegEx.test(urlObj.pathname) === true) {\n    targetGiven = String(`${urlObj.origin}/`);\n    if (startWithOneSlashRegEx.test(asset) === false) {\n      // If asset DOES NOT start with a slash (e.g. <img src=\"a.png\" />)\n      // An array out of the URL, without empty members\n      // e.g. '/a/c.html' => [ '', 'a', 'c.html' ]\n      // With this below, it becomes [ '', 'a', 'c.html' ]\n      const targetAssetPathnameArray = urlObj.pathname.split('/').filter(n => n);\n      targetAssetPathnameArray.pop(); // Strip off file and extension member\n      targetGiven += targetAssetPathnameArray.join('/');\n      if (endWithOneSlashRegEx.test(targetGiven) === false) {\n        targetGiven += '/';\n      }\n    }\n    // Make sure targetGiven ENDS with slash. http://example.org/a/\n  }\n\n  /**\n   * If targetAsset starts by /, we explicitly want\n   * to start directly from the top of the\n   * folder hirerarchy\n   * e.g. /a.png\n   */\n  if (startWithOneSlashRegEx.test(targetAsset)) {\n    // console.log(`Start from top top most parent directory \"${targetAsset}\"`); // DEBUG\n    targetGiven = String(`${urlObj.protocol}//${urlObj.hostname}/`);\n    targetAsset = targetAsset.replace(startWithOneSlashRegEx, '');\n    // Make sure if we had a / at the asset, it's stripped off uniformally\n    // {asset: '/a.png', targetGiven: 'http://example.org/', targetAsset: 'a.png'}\n  }\n\n  /**\n   * How many times has the asset contains \"../\"\n   * and let's handle how deep we can go to a parent directory.\n   *\n   * Here are a few possible edge cases.\n   *\n   * ```\n   * ----\n   * Equal number directory deep and request for going up.\n   * [ { given: 'http://example.org/ignored/also_ignored/and_too',\n   *     targetGiven: 'http://example.org/ignored/also_ignored/and_too/' },\n   *   { asset: '../../../a.jpg', targetAsset: '../../../a.jpg' },\n   *   { isTargetAssetGoUpOverflow: false,\n   *     targetGivenPathname: 3,\n   *     goUp: 3,\n   *     targetAssetArray: [ 'a.jpg' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   *\n   * ----\n   * [ { given: 'http://example.org/ignored/also_ignored/',\n   *     targetGiven: 'http://example.org/ignored/also_ignored/' },\n   *   { asset: '../../a.jpg', targetAsset: '../../a.jpg' },\n   *   { isTargetAssetGoUpOverflow: false,\n   *     targetGivenPathname: 2,\n   *     goUp: 2,\n   *     targetAssetArray: [ 'a.jpg' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   *\n   * ----\n   * File has extension, we cannot treat it as a directory.\n   * [ { given: 'http://example.org/b/c.html',\n   *     targetGiven: 'http://example.org/b/' },\n   *   { asset: '../a.png', targetAsset: '../a.png' },\n   *   { isTargetAssetGoUpOverflow: false,\n   *     targetGivenPathname: 1,\n   *     goUp: 1,\n   *     targetAssetArray: [ 'a.png' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   *\n   * ----\n   * Here, we are asking to go beyond one directory deep.\n   * Notice isTargetAssetGoUpOverflow is true.\n   * [ { given: 'http://example.org/b/c.html',\n   *     targetGiven: 'http://example.org/' },\n   *   { asset: '../../../../../a.png', targetAsset: 'a.png' },\n   *   { isTargetAssetGoUpOverflow: true,\n   *     targetGivenPathname: 1,\n   *     goUp: 5,\n   *     targetAssetArray: [ 'a.png' ],\n   *     newTargetGivenPathname: [],\n   *     sliceUntilHowMany: 0 } ]\n   * ```\n   */\n  if (/\\.\\.\\//.test(targetAsset)) {\n    const goUp = targetAsset.match(/\\.\\.\\//g);\n    // console.log(`Has go up parent operator in path \"${targetAsset}\", found ${goUp.length} times`); // DEBUG\n    const tempTargetGivenUrlObj = new URL(targetGiven);\n    const targetGivenPathname = tempTargetGivenUrlObj.pathname.split('/').filter(n => n);\n    const isTargetAssetGoUpOverflow = targetGivenPathname.length < goUp.length;\n    let sliceUntilHowMany = targetGivenPathname.length - goUp.length;\n\n    // Make sure this edge-case is taken into account so that we can still\n    // calculate how deep we go without overriding.\n    // Maybe that's a mutually exclusive scenario and we need to else from here.\n    if (isTargetAssetGoUpOverflow === true) {\n      // Assuming we have impossible to reach, we got to stop at the origin:\n      // targetGiven = http://example.org/\n      // targetAsset = ../../bogus.png\n      // Force so we serve at the top http://example.org/bogus.png\n      sliceUntilHowMany = 0;\n    }\n\n    const newTargetGivenPathname = targetGivenPathname.slice(0, sliceUntilHowMany);\n    const targetAssetArray = newTargetGivenPathname.concat(targetAsset.split('/').filter(n => n !== '..'));\n    // console.log([{given, targetGiven}, {asset, targetAsset}, {isTargetAssetGoUpOverflow, targetGivenPathname: targetGivenPathname.length, goUp: goUp.length, targetAssetArray, newTargetGivenPathname, sliceUntilHowMany}]);\n    targetGiven = String(`${urlObj.origin}/`);\n    targetAsset = String(`${targetAssetArray.join('/')}`);\n  }\n\n  /**\n   * If targetAsset starts by https?://, we ignore targetGiven\n   */\n  if (startWithHttpMaybeTlsRegEx.test(asset) === true) {\n    targetGiven = '';\n  }\n\n  /**\n   * If targetAsset starts by //, we ignore targetGiven\n   */\n  if (startWithDoublySlashRegEx.test(asset) === true) {\n    targetGiven = (startWithHttpsRegEx.test(urlObj.href) === true) ? 'https:' : 'http:';\n  }\n\n  const ret = String(`${targetGiven}${targetAsset}`);\n  // console.log('normalizer/assets', ret); // DEBUG\n\n  return ret;\n};\n"]}